#!/usr/bin/env python

import sys
import os.path
import argparse
import re

PATTERN_INCLUDE = r'^[^;]*\s*(\.include|\.incbin)\s+"(.+)"'

pattern_include = re.compile(PATTERN_INCLUDE)

if __name__ == '__main__':
    parser = argparse.ArgumentParser(description='autdependencies')
    #parser.add_argument('--include-dir',  dest='include_dir', metavar='DIR')
    parser.add_argument('--include-binary-dir',  dest='include_binary_dir',
            metavar='DIR')
    parser.add_argument('source_file', metavar='SOURCE_FILE')
    args = parser.parse_args()
    
    source = open(args.source_file, 'r')
    deps = [] # to be populated
    source_basename = os.path.basename(args.source_file)
    obj_basename = source_basename.replace('.s', '.o')

    line = None
    line_no = 0
    while line != '':
        line = source.readline() # returns empty str at EOF
        line_no += 1
        # perhaps we could do this with regexes, but the question of balanced
        # strings makes it tricky
        match = pattern_include.match(line)
        if match is None:
            continue
        include_type = match.group(1)
        filename = match.group(2)
        assert(include_type in ('.include', '.incbin'))
        # TODO: follow recursive includes
        #if include_type == '.incbin':
        #    deps.append(os.path.sep.join(
        #        [args.include_binary_dir, filename]))
        #else:
        #    deps.append(filename)
        deps.append(filename)

    print(f"{obj_basename}:\t{' '.join(deps)}\n")
